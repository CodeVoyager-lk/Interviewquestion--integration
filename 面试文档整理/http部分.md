
# HTTP部分

## 📕常见的状态码有哪些

- `100`：客户端在发送POST数据给服务器前，先发送请求头，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输
- `200` 表示从客户端发来的请求在服务器端被正常处理了。
- `204` 表示请求处理成功，但没有资源返回。
- `301` 表示永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。
- `302` 表示临时性重定向。
- `304`：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分
- `400` 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。
- `401` 表示未授权（Unauthorized)，当前请求需要用户验证
- `403` 表示对请求资源的访问被服务器拒绝了
- `404` 表示服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。
- `500` 表示服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。
- `503` 表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

---

## 📕GET 和 POST请求的区别

GET通常用于请求获取指定资源，而POST通常用于将实体提交到指定的资源。本质都是TCP连接，但是由于`HTTP`的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别。

### 区别

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被收藏，而POST不可以。
- GET请求会被浏览器主动缓存，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET参数通过URL传递，POST放在Request body中
- 对参数的数据类型，GET只接受*ASCII*字符，而POST没有限制。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

**参数长度**：`HTTP`协议没有`Body`和 `URL` 的长度限制，对 `URL`限制的大多是浏览器和服务器考虑处理较长的`url`会消耗较多资源，出于性能和安全的考虑限制了url长度

**安全**：本质上两者都是不安全的。因为`HTTP` 在网络上是明文传输的，通过技术手段能完整地获取数据报文，只有使用`HTTPS`才能加密安全

**数据包** ：于`GET`方式的请求，浏览器会把`http header`和`data`一并发送出去，对于`POST`，浏览器先发送`header`，服务器响应100 `continue`，浏览器再发送`data`。但并不是所有浏览器都会在`POST`中发送两次包

---
## 📕浏览器的同源策略

### 什么是源

如果两个URL的协议、主机（域名）和端口号都相同的话，则这两个URL就是同源。**同源策略**是一个重要的安全策略，它定义了源之间资源如何交互，减少可能被攻击的媒介。

### 跨域网络访问

同源策略可以控制不同源之间的交互，例如在发送`Ajax`、`fetch`请求 或使用 `<img>`标签时则会受到同源策略的约束。这些交互通常分为三类：

- 跨源**写操作**（Cross-origin writes）一般是被允许的。例如链接、重定向以及表单提交。
- 跨源**资源嵌入**（Cross-origin embedding）一般是被允许的（后面会举例说明）。
- 跨源**读操作**（Cross-origin reads）一般是不被允许的，但常可以通过内嵌资源来巧妙的进行读取访问

可能嵌入跨源的资源的一些示例：

- 使用 `<script src="…"></script>` 标签嵌入的 JavaScript 脚本。语法错误信息只能被同源脚本中捕捉到。
- 使用 `<link rel="stylesheet" href="…">` 标签嵌入的 CSS。由于 CSS 的松散的语法规则，CSS 的跨源需要一个设置正确的 `Content-Type` 标头。
- 通过 `<img>`展示的图片。
- 通过 `<video>` 和 `<audio>`播放的多媒体资源。
- 通过 `<object>`和 `<embed>`嵌入的插件。
- 通过 `@font-face`引入的字体。一些浏览器允许跨源字体（cross-origin fonts），另一些需要同源字体（same-origin fonts）。
- 通过 `<iframe>`载入的任何资源。

### 如何解决跨域

**jsonp解决同源限制问题**

通过`<script>`标签的src属性实现跨域。`<script>`属于跨源资源嵌入，因此不受同源策略限制。

- 实现jsonp封装
  
  ```js
  function jsonp(options){
      var script = document.createElement("script");
      script.src = options.url;
      document.body.appendChile(srcipt);
      script.onload = function(){
          document.removeChile(srcipt);        
      }
  }
  ```

- 弊端：
  
  1. jsonp只能发送GET请求
  
  2. jsonp没有办法返回后端状态码，没办法改变
  
  3. 存在安全隐患，服务端直接调用方法（不能保证服务器的可靠性）

**CORS实现跨域请求**

是一种基于 `HTTP`头的机制，该机制通过允许服务器标示除了它自己以外的其它源（域、协议或端口不同），使得浏览器允许这些源访问加载自己的资源。

浏览器发出的跨域请求分为两种：

1. 简单请求
   
   满足所有以下条件：
   
   - 请求方法：`GET,HEAD,POST`
   - 请求头的内容—HTTP的头信息不超出以下几种字段：
     - Accept
     - Accept-Language
     - Content-Language
     - Last-Event-ID
     - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`
   
   当浏览器发现发现的ajax请求是简单请求时，会在请求头中携带一个字段：`Origin``Origin`中会指出当前请求url,服务会根据这个值决定是否允许其跨域。
   
   如果服务器允许跨域，需要在返回的响应头中携带`Access-Control-Allow-Origin`：上面`Origin`中的地址或者*代表任意。

2. 特殊请求
   
   不符合简单请求的条件，会被浏览器判定为特殊请求。
   
   特殊请求会在正式通信之前，浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。
   
   与简单请求相比，除了Origin以外，多了两个头：
   
   - Access-Control-Request-Method：接下来会用到的请求方式，比如PUT
   - Access-Control-Request-Headers：会额外用到的头信息
   
   服务的收到预检请求，如果许可跨域，会发出响应，除了简单请求中的两个，还附加：
   
   - Access-Control-Allow-Methods：允许访问的方式
   - Access-Control-Allow-Headers：允许携带的头
   - Access-Control-Max-Age：本次许可的有效时长，单位是秒，**过期之前的ajax请求就无需再次进行预检了**。

---

## 📕DNS协议 是什么？说说DNS 完整的查询过程?

DNS（Domain Names System）解释为域名系统，属于是应用层的协议，用于将用户提供的主机名（域名）解析为 IP 地址。

域名是一个具有层次的结构，从上到下依次为**根域名**、**顶级域名**、**二级域名**、**三级域名**等...

例如`www.baidu.com`，`www`为三级域名、`baidu`为二级域名、`com`为顶级域名，系统为用户做了兼容，域名末尾的根域名`.`一般不需要输入,域名的每层都设有一个域名服务器：

- **根域名服务器（Root DNS Server）**：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址

- **顶级域名服务器（Top-level DNS Server）**：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 baidu.com 域名服务器的 IP 地址

- **权威域名服务器（Authoritative DNS Server）**：管理自己域名下主机的 IP 地址，比如 baidu.com 权威域名服务器可以返回 www.baidu.com的 IP 地址

- **本地域名服务器（Local Name Server，local DNS）**：如果通过 DHCP 配置，由互联网服务提供商（ISP，如联通、电信）提供

<img title="" src="https://static.vue-js.com/9f112780-b78f-11eb-85f6-6fac77c0c9b3.png" alt="" data-align="center">

### DNS查询方式

DNS 查询有两种方式：**递归** 和 **迭代** 。

客户端与本地域名服务器之间一般采用**递归查询**，它负责全权处理客户端的 DNS 查询请求，直到返回最终结果

而 DNS 根域名服务器之间一般采用 **迭代查询** 方式，当DNS 服务器查不到该域名，它不会替客户端完成后续的查询工作，而是回复下一步应当向哪一个域名服务器进行查询

- 递归查询

<img title="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0845436acd5048698644d9dc8d1e1fe6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" width="531" data-align="center">

- 迭代查询

<img title="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30c166d8875d406a98e57f7b81e1211e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" width="498" data-align="center">

### 域名缓存

一次完整的 DNS 查询过程需要访问多台 DNS 服务器才能得到最终的结果，这会带来一定的时延。**为了改善时延**，DNS 服务并不是每次请求都要去访问 DNS 服务器，而是访问过一次后将 DNS 记录缓存在本地。

计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存

**浏览器缓存**：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。但是缓存并不是永久有效的，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS

**操作系统缓存**：操作系统的缓存其实是用户自己配置的 hosts 文件。

**访问顺序为：浏览器缓存 -> 操作系统缓存 -> 路由器缓存 -> local DNS 缓存 -> DNS 查询**

### 查询过程

- 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表

- 若没有命中，则继续搜索操作系统的 DNS 缓存

- 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果

- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
  
  - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
  - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址

- 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来

- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起

- 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

---

## 📕TCP的三次握手与四次挥手

TCP 提供面向有连接的通信传输，面向有连接是指在传送数据之前必须先建立连接，数据传送完成后要释放连接。连接是通过**三次握手**进行初始化的，并且由于TCP是**全双工模式**，所以需要**四次挥手**关闭连接

### TCP序号和确认号

**32位序号 seq**：TCP通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据**有序**，比如现在序列号为1000，发送了1000，下一个序列号就是2000。  
**32位确认号 ack**：TCP对上一次seq序号做出的确认号，给收到的TCP报文段的序号seq加1，用来响应TCP报文段

### TCP标志位

用的最广泛的标志是 **SYN**，**ACK** 和 **FIN**，用于建立连接，确认成功的段传输，最后终止连接。  

- **SYN**：简写为S，同步标志位，用于建立会话连接，同步序列号；

- **ACK**： 简写为.，确认标志位，对已接收的数据包进行确认；

- **FIN**： 简写为F，完成标志位，表示我已经没有数据要发送了，即将关闭连接；

- PSH：简写为P，推送标志位，表示该数据包被对方接收后应立即交`给上层应用，而不在缓冲区排队；

- RST：简写为R，重置标志位，用于连接复位、拒绝错误和非法的数据包；

- URG：简写为U，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；

### TCP三次握手

进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备，TCP三次握手的过程为：

**第一次握手**：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号。此时客户端处于 SYN_SEND 状态。

首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。

**第二次握手**：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。

在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。

**第三次握手**：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1）

![](https://static.vue-js.com/fb489fc0-beb9-11eb-85f6-6fac77c0c9b3.png)

**为什么是三次握手**：第一次握手服务端确定自己的接收能力正常、客户端的发送能力正常；第二次握手客户端确定自己的接收发送能力正常，服务端接受能力和发送能力正常；至此，虽然客户端已经知道能够正常传输接收数据，但是服务器还并不能确认自己发送的数据对方是否能够接收，因此还需要客户端发送确认报文

### TCP四次挥手

TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，称之为半关闭。这使得终止TCP连接需要经历四次挥手，客户端或服务器均可主动发起挥手动作。假如是客户端先发起关闭请求，四次挥手的过程如下：

**第一次挥手** 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u，此时，客户端进入FIN-WAIT-1（终止等待1）状态

**第二次挥手** 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态

**第三次挥手** 客户端接收到服务器端的确认请求后，客户端就会进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文(FIN=1，ACK=1，序号seq=w，确认号ack=u+1)，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

**第四次挥手** 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态，但此时TCP连接还未终止，为了确保服务端收到自己的ACK报文，客户端必须要经过2MSL后（最长报文寿命），才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成

![](https://pic2.zhimg.com/v2-c7d4b5aca66560365593f57385ce9fa9_b.jpg)

---

## 📕回流和重绘

### 回流与重绘

**什么是回流**：当我们对 DOM 的修改引发了 DOM **布局或者几何属性**时（比如修改元素的宽、高或隐藏元素等），浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。

- 全局范围：从根节点 html 开始对整个渲染树进行重新布局。
- 局部范围：对渲染树的某部分或某一个渲染对象进行重新布局

**什么是重绘**：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式。这个过程叫做重绘。

**回流必将引起重绘，重绘不一定会引起回流**

### 常见引起回流的设计

场景：

1. 页面一开始渲染的时候（这肯定避免不了）
2. 添加或者删除可见的 `DOM` 元素；
3. 元素的位置发生变化
4. 元素尺寸改变——边距、填充、边框、宽度和高度;
5. 浏览器窗口尺寸改变——resize 事件发生时
6. 计算 offsetWidth 和 offsetHeight 属性

属性和方法

- width、height、margin、padding、border
- display、position、overflow
- clientWidth、clientHeight、clientTop、clientLeft
- offsetWidth、offsetHeight、offsetTop、offsetLeft
- scrollWidth、scrollHeight、scrollTop、scrollLeft
- scrollIntoView()、scrollTo()
- getComputedStyle()
- getBoundingClientRect()
- scrollIntoViewIfNeeded()

### 常引起重绘的属性和方法
- color
- border-style
- visibility
- background
- text-decoration
- background-image
- background-position
- background-repeat
- outline-color
- outline
- outline-style
- border-radius
- outline-width
- box-shadow
- background-size

### 浏览器优化机制
由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列
但是你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的如offsetTop等方法都会返回最新的数据，因此浏览器不得不清空队列，触发回流重绘来返回正确的值

### 减少回流重绘方案
- 读写分离操作

```js
div.style.left = "10px";
div.style.top = "10px";
div.style.width = "20px";
div.style.height = "20px";
// 分离引用读取
console.log(div.offsetLeft);
console.log(div.offsetTop);
console.log(div.offsetWidth);
console.log(div.offsetHeight);
```
- 样式集中操作

```js
div.style.left = "10px";
div.style.top = "10px";
div.style.width = "20px";
div.style.height = "20px";
```
虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下：建议通过改变 class 或者 csstext 属性集中改变样式
```js
// bad
var left = 10;
var top = 10;
el.style.left = left + "px";
el.style.top = top + "px";
// good
el.className += " theclassname";
// good
el.style.cssText += "; left: " + left + "px; top: " + top + "px;";
el.style.cssText += `; left:${left}px; top:${top}px;`;
```
- 缓存布局信息

```js
// bad
div.style.left = div.offsetLeft + 1 + "px";
div.style.top = div.offsetTop + 1 + "px";

// good 缓存布局信息 相当于读写分离 ；想深入了解缓存优化参考 《小鹦鹉》
var curLeft = div.offsetLeft;
var curTop = div.offsetTop;
div.style.left = curLeft + 1 + "px";
div.style.top = curTop + 1 + "px";
curLeft = curTop = null;
```
- "离线"改变 DOM

（1）隐藏要操作的 dom，在要操作 dom 之前，通过 display 隐藏 dom，当操作完成之后，才将元素的 display 属性为可见，因为不可见的元素不会触发重排和重绘。

（2）通过使用文档碎片创建一个 dom 碎片,在它上面批量操作 dom，操作完成之后，再添加到文档中，这样只会触发一次重排。`document.createDocumentFragment()`

- 优化动画

动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：比如实现一个动画，以 1 个像素为单位移动这样最平滑，但是回流就会过于频繁，大量消耗 CPU 资源；举例优化如果以 3 个像素为单位移动，则会好很多。

- 启用 GPU 加速

GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，它在速度和能耗上更有效率。
GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3 转换（transitions），CSS3 3D 变换（transforms），WebGL 和视频(video)。

---
## 📕浏览器页面渲染
### 页面渲染过程
- 解析HTML，生成DOM树，解析CSS，生成CSSOM树

- 将DOM树和CSSOM树结合，**去除不可见元素(很重要)**，生成渲染树(Render Tree)

- Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）

- Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素

- Display:将像素发送给GPU，展示在页面上

![渲染流程](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9f37924b4034e5aaccec6a2556502bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

什么是不可见节点

- 一些不会渲染输出的节点，比如 script、meta、link 等。
- 一些通过 css 进行隐藏的节点。注意，使用 visibility 和 opacity 隐藏的节点，还是会显示在渲染树上的（因为还占据文档空间），**只有 display : none 的节点才不会显示在渲染树上**。

**渲染树**

![渲染树](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5be05f02ba9140a49e74ef6b1707fad5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 阻塞渲染

#### **css阻塞**

   **css阻塞DOM解析**：当JavaScript 中访问了某个元素的样式，那么这时候就需要 等待这个样式被下载 完成才能继续往下执行，从而css间接阻塞了DOM解析

   **css阻塞渲染树**：CSSOM树的构建阻塞渲染树的构建

#### **js阻塞**

  当 HTML 解析器遇到一个 script 标记时，它会暂停构建 DOM，将控制权移交给 JS 引擎，直到 JS 引擎运行完毕

#### **如何解决css阻塞**

  **CSS引入的位置 —— 针对阻塞 DOM 解析**

  一般我们把`<style>`、`<link>`放在`<head>`里面，提前加载好CSS资源，这样当 JavaScript 请求到样式表时将不必等待 CSS 资源的加载

  **媒体查询的方式 —— 针对阻塞 render 树的构建**

  有些 CSS 资源在首次渲染中可能不用用到，只是在用户交互（比如改变页面大小）时才会用到，所以我们通过媒体查询的方式来判断是否需要在首次渲染加载。这样从某种程度上会减少首屏加载时间

```js
<!-- 适用于所有情况，始终阻塞渲染 -->

  <link href="style.css" rel="stylesheet">

  <!-- 网页首次加载时，只在打印内容时适用 -->

  <link href="print.css" rel="stylesheet" media="print">

  <!-- 如果不是在打印内容时，该样式表不阻塞渲染 -->

  <!-- 符合条件时浏览器将阻塞渲染，直至样式表下载并处理完毕 -->

  <link href="other.css" rel="stylesheet" media="(max-width: 400px)">

  <!-- 如果不满足条件，不会阻塞渲染，但依旧会请求下载对应的资源 -->
```

#### **如何解决js阻塞**

- `<script>`标签引入位置

如果页面渲染内容为`<script>`标签请求的内容，则该`<script>`标签一般需要放在`<head>`里面

如果页面渲染内容跟`<script>`标签内容无关的话，比如说 **DOM 事件**、加载其他（还未见的）内容，则该`<script>`标签一般放在`<body>`标签里的最后位置

- defer 和 async 属性

如果需要某段 JavaScript 代码需要提前加载，即可能会放在`<head>`里面或某些 DOM 节点前面，则给`<script>`标签添加 defer 或 async 属性：

- 如果加载完需要 **立刻执行** 则使用 `async` 属性；
- 如果加载完不需要立刻执行，想要在页面结构加载完(`window.onload`)再立刻执行的话，使用 `defer` 属性； 值得注意的是：

没有使用这两种属性之一的话，则 JavaScript 的加载和运行都会阻塞渲染，有的话只有运行会阻塞

---

## 📕说说地址栏输入 URL 敲下回车后发生了什么?从输入URL的行

在浏览中输入 URL 并且获取响应的过程，其实就是浏览器和该 URL 对应的服务器的网络通信过程。从输入 `URL`到回车后发生的行为主要有几个过程：

`URL解析`—> `DNS 查询`—>`TCP 连接`—>`HTTP 请求`—>`响应请求`—>`页面渲染`

### URL解析

当用户输入一个完整的`URL`之后，浏览器就开始解析`URL`的构成。一个`URL`的结构是由这些部分组成的：

![](https://static.vue-js.com/27a0c690-bdf4-11eb-ab90-d9ae814b240d.png)

### DNS查询

在用户输入的`URL`中包含域名，然而域名并不是目标服务器真正意义上的地址，我们需要通过DNS解析获取相对应的IP地址，查询过程如下（详见[DNS协议查询过程](#📕dns协议-是什么说说dns-完整的查询过程)，这里不详述）：

<img src="https://gitee.com/veal98/images/raw/master/img/20210120123619.png" title="" alt="" data-align="center">

### TCP连接

`tcp`是一种面向有连接的传输层协议，在确定目标服务器服务器的`IP`地址后，则经历三次握手建立`TCP`连接（之前有讲过，这里不细讲），**保证双方都具有可靠的接收和发送能力**（详见[TCP三次握手](#tcp三次握手)）

![](https://gitee.com/veal98/images/raw/master/img/20210107175526.png)

### 浏览器发送请求

当建立`tcp`连接之后，就可以在这基础上进行通信，浏览器发送 `http` 请求到目标服务器

请求的内容包括：

- 请求行
- 请求头
- 请求主体

<img title="" src="https://ask.qcloudimg.com/http-save/yehe-3733321/7xtjn9diju.png?imageView2/2/w/2560/h/7000" alt="" width="632">

### 服务器响应请求

当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个`HTTP`响应消息，包括：

- 状态行
- 响应头
- 响应正文

![](https://static.vue-js.com/c5fe0140-bdf4-11eb-ab90-d9ae814b240d.png)

### 断开TCP连接

浏览器和服务器都不再需要发送数据后，四次挥手断开 TCP 连接，任意一方都可以发起关闭请求（详见[TCP四次挥手](#tcp四次挥手)）

### 页面渲染

关于页面的渲染过程如下（详见[浏览器页面渲染](#📕浏览器页面渲染)）：

- 解析HTML，构建 DOM 树
- 解析 CSS ，生成 CSS 规则树
- 合并 DOM 树和 CSS 规则，生成 render 树
- 布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算
- 绘制 render 树（ paint ），绘制页面像素信息
- 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上

---

## 📕web性能优化

web性能是客观的衡量标准，是用户对加载时间和运行的直观体验。web性能指页面加载到可交互和可响应所消耗的时间，以及页面在交互时的流畅度。

### web性能报告

我们可以通过Chrome的扩展程序lighthouse、Pingdom等工具得到FCP（First Contentful Paint）白屏时间、SI（Speed Index）页面渲染时间、TBT（Total Blocking Time）用户行为阻塞时间等，从而分析网页每部分的性能问题，同时它们也会给出相应的优化意见可以供我们参考，如果我们想要优化性能可以从以下几个方面入手：

### 提高资源响应速度

资源响应速度的主要优化点在于：减少请求数、减少请求资源体积、提升网络传输效率

- **使用 CDN 加速**：内容分发网络，通过设置边缘结点缩短用户与服务端地理距离，从而来缩短请求静态资源时间。（详见[如何理解CDN](#📕如何理解cdn-说说实现原理)）

- **开启gzip压缩**：使用 gzip 压缩编码技术，减小资源体积。gzip通常需要web 服务器和客户端(浏览器)必须同时支持 gzip。gzip 压缩效率非常高，通常可达 70% 压缩率
- **浏览器缓存**：前端缓存一般可分为 http缓存和浏览器缓存，http缓存还分**强缓存**和**协商缓存**，浏览器缓存，比如`localStorage`,`sessionStorage`,`cookie`等（详见[浏览器缓存策略](#📕如何理解浏览器缓存策略（http缓存）)）
- **减少网络请求次数和体积**：通过压缩文件及合并小文件为大文件，减少网络请求次数，但需要找到合理的平衡点。
- **使用 HTTP/2**（HTTP2的优势见[HTTP1.0/HTTP1.1/HTTP2.0的区别](#📕说说http1.0/http1.1/http2.0的区别)）

### 资源体积优化

- 文本资源（包括`HTML`、`css`、`js`等）：组件按需加载、代码按需打包、按需引入第三方样式文件等

- 图片资源

  `字体图标代替图片图标`
   一些通用的小图标，如箭头，叉，可以使用字体图标，减少请求，渲染更快

  `精灵图（没有字体图标效果好）`
   一些带有企业特色的小图标，如淘宝购物车，笑脸娃娃，可以使用精灵图，让一张图上带有多个小图，然后使用css背景定位来显示出合适的位子，能大大减少请求

  `图片懒加载`
   为了首屏渲染更快，图片可设置一张加载图代替，当页面在可视区域内时在替换为真正的图片
   如果有首屏很大的高清图，可先渲染清晰度低的缩略图，在首页基本构建完成下一次事件循环再去替换为高清图

  `图片预加载`
   可以在window.onload之后请求一些其他地方需要的图片资源
   比如我们有一个活动页使用了高清图，我们可以在它的入口前的首页就加载它，当我们进去页面时，浏览器就会从缓存里读取这张图片

  `使用png格式的图片`
   PNG 格式是WEB 图像中最通用的格式，它是一种无损压缩格式

  `小于10k的图片可以打包为base64格式`
   可以使用webpack url-loader处理优化代码质量

### 提高代码质量

- 精简代码：
  - 使用 `lodash` 提供的功能函数
  - 使用ES6语法
  - 去除无效代码、封装共用模块代码提高代码耦合性
- 代码性能：
  - 降低代码时间、空间复杂度、
  - 减少会引起回流、重绘的代码操作（具体方案见[回流和重绘](#📕回流和重绘)）
  - 使用防抖和节流控制请求频率（[防抖和节流](#📕什么是防抖和节流有什么区别如何实现)）等
- 代码设计：
  - 优化长列表—使用`virtual-list`方案只给DOM添加当前屏幕显示的DOM节点
  - 避免 ifarme 嵌套网页
- 降低内存占用
  - 合理使用闭包，防止内存泄漏
  - 将使用的定时器及时清除
  - 避免循环引用
  - DOM删除时解绑事件等

### 完善用户体验

在设计页面的时候考虑到用户的习惯性行为，在用户操作的过程中给出网页使用的引导，在页面加载遇到问题时给与友好提示、考虑到用户的视觉变化在设计弹窗等网页行为时给一个过渡的效果等等......

---

## 📕如何理解CDN 说说实现原理

CDN，即内容分发网络。它是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。

### CDN原理分析

在没有应用`CDN`时，我们使用域名访问某一个站点时的路径为

> 用户提交域名→浏览器对域名进行解释→`DNS` 解析得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复

应用`CDN`后，`DNS` 返回的不再是 `IP` 地址，而是先返回一个`CNAME`(Canonical Name ) 别名记录，指向`CDN`的全局负载均衡，这个全局负载均衡系统会综合用户地理位置、运营商网络、边缘结点的负载情况等因素进行智能调度，计算最合适的边缘节点并返回给用户，具体流程如下：

①、当用户点击APP上的内容，APP会根据URL地址去**本地DNS**（域名解析系统）寻求IP地址解析。

②、本地DNS系统会将域名的解析权交给**CDN专用DNS服务器**。

③、CDN专用DNS服务器，将CDN的全局负载均衡设备IP地址返回用户。

④、用户向**CDN的负载均衡设备**发起内容URL访问请求。

⑤、CDN负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的**缓存服务器**。

⑥、负载均衡设备告诉用户这台缓存服务器的IP地址，让用户向所选择的缓存服务器发起请求。

⑦、用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。

⑧、如果这台缓存服务器上并没有用户想要的内容，那么这台缓存服务器就要网站的**源服务器**请求内容。

⑨、源服务器返回内容给缓存服务器，缓存服务器发给用户，并根据用户自定义的缓存策略，判断要不要把内容缓存到缓存服务器上。

<img src="D:\study\前端😁\前端面试相关（基础知识）\素材\负载均衡.webp" alt="负载均衡" style="zoom:80%;" />

### CDN缓存代理

缓存系统是 `CDN`的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源，其中有两个衡量`CDN`服务质量的指标：

- **命中率**：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比
- **回源率**：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比

缓存系统也可以划分出层次，分成**一级缓存节点**和**二级缓存节点**。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户

回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源

现在的商业 `CDN`命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上

---

## 📕如何理解浏览器缓存策略（HTTP缓存）

HTTP缓存：缓存命中机制主要分为两个阶段—**强缓存**和**协商缓存。**浏览器是否启动缓存，主要是服务器来设置。当该资源首次被请求时，服务器通过设置HTTP响应的响应头来设置该资源的缓存信息

相同点：**其中无论是哪种缓存命中，最终使用的都是浏览器缓存到本地的资源**

不同点：**强缓存不发生网络请求。**

### 强缓存

**定义**：强缓存主要是浏览器自行判断资源是否过期，如果不过期则直接使用缓存的资源（强缓存命中），不再进行网络请求

**实现**：强缓存是利用`Expires`、`Cache-Control`或者`Pragma`这三个http response header实现的

**优先级`Pragma` > `Cache-Control` > `Expires`，其中`Pragma`不常用**

#### Expires

- HTTP 1.0 用于缓存管理的`header`字段，由服务器返回值表示一个资源过期的时间，描述的是属于服务端时间系统的一个绝对时间
- 判断方法：浏览器发起下一次请求时，当前HTTP发起的请求时间 `(this http request time) < (expires设置的值)`，资源没有过期，缓存命中。
- 弊端：`Expires`遵循的是服务端的时间系统，而请求时间遵循的是客户端的时间系统，如果两者时间不是一致的，就可能产生误差

#### Cache-Control

为了解决Expires因为客户端和服务器端时间不统一带来的问题，HTTP 1.1 提出了 `Cache-Control` ，这个字段使用相对时间以秒为单位、用数值表示，进行比较的时候用的都是客户端的时间，相对来更有效与安全。

- 判断方法：浏览器发起下一次请求时，当前HTTP发起的请求时间`(this http request time) < (last http request time + cache-control 设置的值)` ，资源没有过期，缓存命中。

该`header`字段的其他取值如下：

| 字段名           | 位置          | 说明                                                         |
| ---------------- | ------------- | ------------------------------------------------------------ |
| no-cache         | 请求头,响应头 | 强制客户端向服务器发送请求（禁止**强缓存**）                 |
| no-store         | 请求头,响应头 | 禁止一切缓存。客户端和代理服务器都不能缓存响应。             |
| max-age          | 请求头,响应头 | 设置资源可以被缓存多长时间，单位是秒。                       |
| no-transform     | 请求头,响应头 | 代理不可更改媒体类型                                         |
| cache-extension  | 请求头,响应头 | 新指令标记（token）                                          |
| s-maxage         | 响应头        | 和max-age同理，只不过是针对代理服务器缓存而言。              |
| private          | 响应头        | 不能被代理服务器缓存                                         |
| public           | 响应头        | 响应可以被任何缓存区缓存                                     |
| must-revalidate  | 响应头        | 在缓存过期前可以使用，缓存过期以后必须向服务器验证。         |
| proxy-revalidate | 响应头        | 要求中间缓存服务器对缓存的响应有效性需再次确认（代理服务器需要发送请求给服务器端确认资源有效性，不能直接返回缓存） |
| only-if-cached   | 请求头        | 从缓存中获取资源                                             |
| min-fresh        | 请求头        | 单位：秒，期望在指定的时间内，响应仍有效                     |
| max-stale        | 请求头        | 单位：秒， 接受已过期的响应                                  |

**Pragma优先级最高，就一个值`no-cache`等同于`Cache-Control` 中 `no-cache`**

**缓存命中**：当强缓存命中时，HTTP状态码为200，资源从缓存中加载（ `from memory cache` / `from disk cache`）

- `from memory cache`：是把资源存到内存中，当进程退出时（关闭浏览器），内存中的数据会清空
- `from disk cache`：是把资源缓存在磁盘中，进程退出时不受影响

### 协商缓存

在强缓存阶段无法命中的情况下，浏览器发起请求，询问服务器是否可以使用本地缓存资源，如果服务器检查发现浏览器本地的资源没有过期，则返回304告诉浏览器可以使用本地的缓存资源（协商缓存命中），否则返回200正常响应，协商缓存主要由``Last-Modified` 和`Etag` 两个`HTTP头`实现：

#### Last-Modified / If-Modified-Since

浏览器发送请求时，会将上次响应头中的 `Last-Modified` 赋值给 本次请求头中的 `If-Modified-Since` 字段。服务端中接收到请求之后，会将这个字段和当前资源最后的修改时间做对比，

- 如果 `If-Modified-Since` （上一次资源修改时间） < 服务器上资源的最后修改时间（发送请求时间晚于服务器资源最后修改时间），则说明当前资源被**修改过了**，服务端需要返回新的资源，此时响应200，返回正常的响应。同时这次响应会返回新的`Last-Modified` 值，用于更新浏览器缓存。
- 如果 `If-Modified-Since` （上一次资源修改时间）≥ 服务器上资源的最后修改时间，则说明没有修改过资源，则返回**304**状态码，不会返回资源内容。

弊端：

- 短时间内资源发生了变化，这个字段并不会发生变化，缓存命中可能失效。
- 如果出现了服务器资源因为反复修改，但资源内容并没发生变化，此时浏览器再次请求服务器，实际上应该认为缓存命中（实际内容没有变化），但是此时通过该字段的比较会导致缓存命中失败

#### Etag/ If-None-Match（优先级最高）

为了解决Last-Modifed的缓存命中问题，可以通过`Etag`来管理协商缓存命中。

- 服务端收到响应以后，根据当前资源内容重新生成一份`Etag` ，比较该值和`If-None-Match` 是否相等，相等（内容没有发生改变）则返回**304**，不相等则返回200和正常响应。但同`Last-Modified` 的区别在于即使服务器重新生成的`Etag`字段和原来的没有变化，但是因为重新生成了，304响应中同样会返回`Etag`字段。

<img src="D:\study\前端😁\前端面试相关（基础知识）\素材\浏览器缓存流程.webp" alt="浏览器缓存过程" style="zoom: 50%;" />

---

## 📕说说HTTP1.0/HTTP1.1/HTTP2.0的区别

### HTTP1.0—无状态无连接

HTTP/1.0规定浏览器和服务器保持短暂的连接。浏览器的每次请求都需要与服务器建立一个TCP连接

- 无连接：服务器处理完成后立即断开TCP连接
- 无状态：服务器不跟踪每个客户端也不记录过去的请求

问题：

1. 无法复用连接。每次发送请求的时候都需要完成一次TCP连接释放的过程，会导致网络的利用率非常低。

2. 队头堵塞(head of line blocking)。由于HTTP/1.0规定下一个请求必须在前一个请求响应到达之后才能发送。如果上一个请求响应一直不到达，那么下一个请求就不发送，就到导致阻塞后面的请求。

### HTTP1.1—长连接请求管道化

**特点**：为了解决HTTP1.0的问题，推出了HTTP1.1

- 长连接：HTTP/1.1增加了一个`Connection`字段，通过设置`Keep-alive`（默认已设置）可以保持连接不断开，客户端可以通过在请求头中携带`Connection:false`来告知服务器关闭TCP连接
- 支持请求管道化（pipelining）：HTTP管道化让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列），客户端可以同时发起多个请求，但是服务端还是会按序依次发送响应

**问题**：

​	虽然HTTP/1.1支持管道化，但是服务器也必须进行逐个响应的送回，依旧无法解决队头阻塞的问题

**增加HTTP头**：`HTTP1.1`在`HTTP1.0`的基础上，增加更多的请求头和响应头来完善的功能，如下：

- 引入了更多的缓存控制策略，如cache-control, If-Match, If-None-Match等缓存头来控制缓存策略
- 引入range，允许值请求资源某个部分
- 引入host，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点（一个服务器能够用来创建多个Web站点）

并且还添加了其他的**请求方法**：`put`、`delete`、`options`...

### HTTP2.0

#### 二进制分帧

HTTP/2 采用**二进制格式**传输数据，而非 HTTP/1.x 的文本格式，二进制协议解析起来**更高效**。HTTP/2 将请求和响应数据分割为更小的**帧**，并**采用二进制编码**

#### 多路复用

`HTTP/2` 复用`TCP`连接，在一个连接里，客户端和浏览器都可以**同时**发送多个请求或回应，而且不用按照顺序一一对应，避免了”队头堵塞”

- 同域名下所有通信都在单个连接上完成
- 该连接可以承载任意数量的双向数据流
- 每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。
- 多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件

#### 服务器推送

`HTTP2`引入服务器推送，允许服务端推送资源给客户端。服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应

但是，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送`RST_STREAM`帧来拒收

#### 头部压缩

HTTP/2.0通过在通讯双方各自`cache`一份”首部表”来跟踪和存储之前发送的键值对，每次响应和请求只发送“首部表”中差异数据，既避免了重复`header`的传输，又减小了需要传输的大小。“首部表”在连接中始终存在，由通信双方共同渐进的更新

<img src="D:\study\前端😁\前端面试相关（基础知识）\素材\首部压缩.png" alt="首部压缩" style="zoom:80%;" />

